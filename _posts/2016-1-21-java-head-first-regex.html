---
layout: post_page
title:  "Java-Head First Regex"
date:   2016-1-21 21:50:56 +1030
categories: Java
tags: [Java]
---
<!DOCTYPE html>
<html>
<head>
<style>
table, th, td {
    border: 1px solid black;
    border-collapse: collapse;
}
th, td {
    padding: 5px;
}
</style>
</head>
<body>
  <table>
<tr ><td style="min-width:100px">\s+ </td><td>one or more whitespace</td></tr>
<tr><td>^\d+(\.\d+)?</td><td>
^ defines that the patter must start at beginning of a new line.
\d+ matches one or several digits.
The ? makes the statement in brackets optional. \. matches ".",
Matches for example "5", "1.5" and "2.21".</td></tr>
<tr><td>\s ^->\S</td><td>A whitespace character, [ \t\n\x0b\r\f]</td></tr>
<tr><td>\w ^->\W</td><td>word character [a-zA-Z_0-9]</td></tr>
<tr><td>\b ^->\B</td><td>word boundary where a word character is [a-zA-Z0-9_]</td></tr>
<tr><td>\G	</td><td>match to occur only at the end of the previous match</td></tr>
<tr><td>*</td><td>{0,}</td></tr>
<tr><td>+</td><td>{1,}</td></tr>
<tr><td>?</td><td>{0,1}</td></tr>
<tr><td>|</td><td>or</td></tr>
<tr><td>*?</td><td>? after a quantifier makes it a reluctant quantifier.
It tries to find the smallest match. This makes the regular expression stop at the first match.</td></tr>

</table>
{%highlight java%}
Enter your regex: ^dog$
Enter input string to search: dog
I found the text "dog" starting at index 0 and ending at index 3.

Enter your regex: ^dog$
Enter input string to search:       dog
No match found.

Enter your regex: \s*dog$
Enter input string to search:             dog
I found the text "            dog" starting at index 0 and ending at index 15.

Enter your regex: ^dog\w*
Enter input string to search: dogblahblah
I found the text "dogblahblah" starting at index 0 and ending at index 11.

 \bdog\b
 The dog plays in the yard. true
 The doggie plays in the yard. false
 \bdog\B
 The dog plays in the yard. false
 The doggie plays in the yard. true

 // Extract the text between the two title elements
 pattern = "(?i)(<title.*?>)(.+?)(</title>)";
 String updated = EXAMPLE_TEST.replaceAll(pattern, "$2");
 //Negative look ahead are defined via (?!pattern)
 //the following will match "a" if "a" is not followed by "b".
 (?!b)

 [abc]	//a, b, or c (simple class)
 [^abc]	//Any character except a, b, or c (negation)
 [a-zA-Z]	//a through z or A through Z, inclusive (range)
 [a-d[m-p]]	//a through d, or m through p: [a-dm-p] (union)
 [a-z&&[def]]	//d, e, or f (intersection)
 [a-z&&[^bc]]	//a through z, except for b and c: [ad-z] (subtraction)
 [a-z&&[^m-p]]	//a through z, and not m through p: [a-lq-z](subtraction)

 Enter your regex: a?
 Enter input string to search:
 I found the text "" starting at index 0 and ending at index 0.

 Enter your regex: a*
 Enter input string to search:
 I found the text "" starting at index 0 and ending at index 0.

 Enter your regex: a+
 Enter input string to search:
 No match found.

 Enter your regex: a?
 Enter input string to search: a
 I found the text "a" starting at index 0 and ending at index 1.
 I found the text "" starting at index 1 and ending at index 1.

 Enter your regex: a*
 Enter input string to search: a
 I found the text "a" starting at index 0 and ending at index 1.
 I found the text "" starting at index 1 and ending at index 1.

 Enter your regex: a+
 Enter input string to search: a
 I found the text "a" starting at index 0 and ending at index 1.


Enter your regex: a{3}
Enter input string to search: aaaa
I found the text "aaa" starting at index 0 and ending at index 3.
Here, the regular expression a{3} is searching for three occurrences of the letter "a" in a row. 
The first test fails because the input string does not have enough a's to match against. 
The second test contains exactly 3 a's in the input string, which triggers a match. 
The third test also triggers a match because there are exactly 3 a's at the beginning of the input string. 
Anything following that is irrelevant to the first match. 
If the pattern should appear again after that point, it would trigger subsequent matches:

 
Enter your regex: a{3}
Enter input string to search: aaaaaaaaa
I found the text "aaa" starting at index 0 and ending at index 3.
I found the text "aaa" starting at index 3 and ending at index 6.
I found the text "aaa" starting at index 6 and ending at index 9.


Backreferences

The section of the input string matching the capturing group(s) is saved in memory for later recall via backreference. 
A backreference is specified in the regular expression as a backslash (\) followed by a digit indicating the number of the group to be recalled. 
For example, the expression (\d\d) defines one capturing group matching two digits in a row, which can be recalled later in the expression via the backreference \1.
Enter your regex: (\d\d)\1
Enter input string to search: 1212
I found the text "1212" starting at index 0 and ending at index 4.
Enter your regex: (\d\d)\1
Enter input string to search: 1234
No match found.
To require the match to occur only at the end of the previous match, use \G:

 
Enter your regex: dog 
Enter input string to search: dog dog
I found the text "dog" starting at index 0 and ending at index 3.
I found the text "dog" starting at index 4 and ending at index 7.

Enter your regex: \Gdog 
Enter input string to search: dog dog
I found the text "dog" starting at index 0 and ending at index 3.
Here the second example finds only one match, because the second occurrence of "dog" does not start at the end of the previous match.

 
{%endhighlight%}
POSIX character for US-ASCII only, not a good chocie (different languages)

Reference
<em>Java Regex - Tutorial</em><br>
http://www.vogella.com/tutorials/JavaRegularExpressions/article.html<br>
<em>Boundary Matchers</em><br>
https://docs.oracle.com/javase/tutorial/essential/regex/bounds.html



</body>
</html>
