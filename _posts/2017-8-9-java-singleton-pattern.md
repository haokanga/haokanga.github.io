--- 
layout: post
title: "Java-Singleton Pattern"
date: 2017-8-9 12:50:56 -0500
categories: Java
tags: [Java]
---	
> Learn how to use singleton and how not to overuse it.
<!--summary break-->

#### Eager initialization

An implementation of the singleton pattern must:

1. ensure that only one instance of the singleton class ever exists
2. provide global access to that instance.

Typically, this is done by:

1. declaring all constructors of the class to be private
2. providing a public static method that returns a reference to the instance

The instance is usually stored as a private static variable; the instance is created when the variable is initialized, at some point **before** the static method is first called.

{% highlight java %}
public final class Singleton {
    private static final Singleton INSTANCE = new Singleton();

    private Singleton() {}

    public static Singleton getInstance() {
        return INSTANCE;
    }
}
{% endhighlight %}

Drawback:
1. In most of the scenarios, Singletons are created for resources such as File System, Database connections, etc. Instantiation should wait until client calls `getInstance()`.
2. No way for exception handling.

#### Static block initialization

Similar to eager initialization, except that instance of class is created in the static block that provides option for exception handling.

{% highlight java %}
public final class Singleton {

    private static Singleton instance;

    private Singleton(){}

    //static block initialization for exception handling
    static{
        try{
            instance = new Singleton();
        }catch(Exception e){
            throw new RuntimeException("Exception occured in creating singleton instance");
        }
    }

    public static Singleton getInstance(){
        return instance;
    }
}

{% endhighlight %}

#### Thread unsafe lazy initialization

The goal of lazy initialization is to defer initializing an object until needed while at the same ensuring it is only initialized once.

{% highlight java %}
@NotThreadSafe
public class Singleton {

    private static Singleton instance;

    private Singleton(){}

    public static Singleton getInstance(){
        if(instance == null){
            instance = new Singleton();
        }
        return instance;
    }
}
{% endhighlight %}

The problem is that this does not work when using multiple threads. There can be race conditions and either they may both try to create the object at the same time, or one may wind up getting a reference to an incompletely initialized object.

#### Thread-safe solution with expensive synchronization

{% highlight java %}
@ThreadSafe
public class Singleton {

    private static Singleton instance;

    private Singleton(){}

    public synchronized static Singleton getInstance(){
        if(instance == null){
            instance = new Singleton();
        }
        return instance;
    }
}
{% endhighlight %}

The first call to getHelper() will create the object and only the few threads trying to access it at the beginning need to be synchronized; after that all calls just get a reference to the member variable. Since synchronizing a method could in some extreme cases decrease performance by a factor of 100 or higher, the overhead of acquiring and releasing a lock every time this method is called seems unnecessary: once the initialization has been completed, acquiring and releasing the locks would appear unnecessary.

Meanwhile, bear in mind that premature optimization is the root of all evil.

> For most applications, the cost of simply making the getHelper() method synchronized is not high. You should only consider this kind of detailed optimizations if you know that it is causing a substantial overhead for an application. -- Bill Pugh

The following will show the tweaks when you try to optimize the program instead of the plain synchronized solution.

#### (Broken) "Double-Checked Locking" idiom
{% highlight java %}
@NotThreadSafe
public class Singleton {

    private static Singleton instance;

    private Singleton(){}

    public static Singleton getInstance(){
        // double-checked locking idiom
        if(instance == null){
            synchronized(Singleton.class) {
                if(instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
{% endhighlight %}

 However, this technique has subtle problems, e.g. consider the following sequence of events:

1. Thread A notices that the value is not initialized, so it obtains the lock and begins to initialize the value.
2. Due to the semantics of some programming languages, the code generated by the compiler is allowed to update the shared variable to point to a **partially constructed object** before A has finished the initialization. In Java if a call to a constructor has been inlined then the shared variable may immediately be updated once the storage has been allocated but before the inlined constructor initializes the object.
3. Thread B notices that the shared variable has been initialized (or so it appears), and returns its value. Because thread B believes the value is already initialized, it does not acquire the lock. If B uses the object before all of the initialization done by A is seen by B (either because A has not finished initializing it or because some of the initialized values in the object have not yet percolated to the memory B uses (cache coherence)), the program will likely crash.
4. To make things worse, using double-checked locking in J2SE 1.4- will often appear to work: it is not easy to tell a correct implementation from a wrong one with such subtle problems. Depending on the compiler, the interleaving of threads by the scheduler and the nature of other concurrent system activity, failures resulting from an incorrect implementation of double-checked locking may only occur intermittently. Reproducing the failures can be difficult.

#### (Fixed) "Double-Checked Locking" idiom with volatile

As of J2SE 5.0, this problem has been fixed. The `volatile` keyword ensures that multiple threads handle the singleton instance correctly (does not work under JDK 1.4-).

{% highlight java %}
-   @NotThreadSafe
+   @ThreadSafe
-   private static Singleton instance;
+   private static volatile Singleton instance;
}
{% endhighlight %}

By adding a local variable `result`, when the instance is already initialized (i.e., most of the time), the volatile field is only accessed once (due to "return result;" instead of "return helper;"), which can improve the method's overall performance.

{% highlight java %}
@ThreadSafe
public class Singleton {

    private static volatile Singleton instance;

    private Singleton(){}

    public static Singleton getInstance(){
        Singleton result = instance;
        if(result == null){
            synchronized(Singleton.class) {
                result = instance;
                if(result == null){
                    instance = result = new Singleton();
                }
            }
        }
        return result;
    }
}

{% endhighlight %}

It also works if Singleton is an immutable object, such that all of the fields of Singleton are final, then double-checked locking will work without having to use volatile fields. The idea is that a reference to an immutable object (such as a String or an Integer) should behave in much the same way as an int or float; reading and writing references to immutable objects are atomic.

Such pitfalls can be easily overlooked if you keep writing Yet Another Java Accounting Application without reading JLS and unaware of anything about Java bytecode, processors, etc. It is just so easy to take everything for granted and assume everything will work using Java and this is the reason that Joel Spolsky criticizes that Java schools mostly produce mediocre programmers instead of the great ones. The least expected behaviors can lead to severe crash, unless you have insight about old-school real CS knowledge.

If the helper object is static (one per class loader), an alternative is the initialization-on-demand holder idiom.

#### Initialization-on-demand holder idiom

Initialization-on-demand holder idiom is a lazy-loaded singleton. In all versions of Java, the idiom enables a safe, highly concurrent lazy initialization with good performance.

{% highlight java %}
@ThreadSafe
public class Singleton {
    private Singleton() {}

    private static class LazyHolder {
        static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return LazyHolder.INSTANCE;
    }
}
{% endhighlight %}

The implementation of the idiom relies on the initialization phase of execution within the JVM as specified by the [Java Language Specification (JLS)](https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.4). When the class `Singleton` is loaded by the JVM, the class goes through initialization. Since the class does not have any static variables to initialize, the initialization completes trivially. The static class definition `LazyHolder` within it is not initialized until the JVM determines that `LazyHolder` must be executed. The static class `LazyHolder` is only executed when the static method `getInstance` is invoked on the class `Singleton`, and the first time this happens the JVM will load and initialize the `LazyHolder` class. The initialization of the `LazyHolder` class results in static variable `INSTANCE` being initialized by executing the private constructor for the outer class `Singleton`. **Since the class initialization phase is guaranteed by the JLS to be serial, i.e., non-concurrent, no further synchronization is required in the static getInstance method during loading and initialization.** And since the initialization phase writes the static variable INSTANCE in a serial operation, all subsequent concurrent invocations of the getInstance will return the same correctly initialized INSTANCE without incurring any additional synchronization overhead.

While the implementation is an efficient thread-safe "singleton" cache without synchronization overhead, and better performing than synchronization, the idiom can only be used when the construction of `Singleton` can be guaranteed to not fail. In most JVM implementations, if construction of `Singleton` fails, subsequent attempts to initialize it from the same class-loader will result in a `NoClassDefFoundError` failure.

#### Break singleton pattern

Reflection can be used to destroy all the above singleton implementation approaches.

In distributed systems, it can be required to implement Serializable interface in Singleton class so that we can store itâ€™s state in file system and retrieve it later. Deserialization will create a new instance of the class each time, unless `readResolve()` method is implemented to return the singleton object.

Joshua Bloch suggests a controversial use of Enum to implement Singleton which can guard against both cases.

#### Singleton as global state?
My original motivation to look into singleton is that I need global shared configuration across classes, however, singleton as global state is so widely criticized. It is such a tempting option but it brings long-term issues such as high coupling and test difficulty. The preferred alternative is Dependency Injection. Singletons as global state make APIs lie about the dependencies. To really figure out the dependencies, developers must read every line of code.


